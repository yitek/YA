
function defineMembers(target:any,props?:any,des?:boolean|PropertyDecorator){
    props ||(props=target);
    let descriptor = {enumerable:false,writable:true,configurable:false,value:undefined};
    if(des===true) descriptor.writable=true;
    else if(des===false) descriptor.writable = false;
    else if(des) for(const n in descriptor) descriptor[n] = des[n];
    for(const n in props){
        descriptor.value = props[n];
        Object.defineProperty(target,n,descriptor);
    } 
    return target;
}
export function intimate(strong?:boolean|any,members?:any){
    if(members){
        for(const n in members){
            Object.defineProperty(strong,n,{enumerable:false,writable:true,configurable:true,value:members[n]});
        }
        return;
    }
    return function(target:any,propName?:string){
        if(propName!==undefined) {
            Object.defineProperty(target,propName,{enumerable:false,writable:!strong,configurable:strong!==true,value:target[propName]});
        }else{
            target = typeof target ==="function"?target.prototype:target;
            for(let n in target) Object.defineProperty(target,n,{enumerable:false,writable:!strong,configurable:strong!==true,value:target[n]});
        }
    }
}

//===============================================================================


/**
 * 可监听对象接口
 *
 * @export
 * @interface IObservable
 * @template TEvtArgs 事件参数的类型
 */
export interface ISubject<TEvtArgs>{
     
    /**
     * 内部的主题列表，可以访问它，但不推荐直接使用，主要是debug时使用
     * 如果不指明主题topic，默认topic=""
     * @type {[topic:string]:Function[]}
     * @memberof ISubject
     */
    

    $_topics:{[topic:string]:Function[]};
    
    /**
     * 注册监听函数
     * $notify的时候，注册了相关主题的监听函数会被调用
     * 如果不指明主题topic，默认topic=""
     *
     * @param {(string|{(evt:TEvtArgs):any})} topicOrListener 监听函数或则主题
     * @param {{(evt:TEvtArgs):any}} [listener] 监听函数。如果第一个参数是主题，该参数才起作用。
     * @returns {ISubject<TEvtArgs>} 可监听对象
     * @memberof IObservable
     */
    $subscribe(topicOrListener:string|{(evt:TEvtArgs):any},listener?:{(evt:TEvtArgs):any}):ISubject<TEvtArgs>;
    
    /**
     * 取消主题订阅
     * $notify操作时，被取消的监听器不会被调用
     * 如果不指明主题topic，默认topic=""
     *
     * @param {(string|{(evt:TEvtArgs):any})} topicOrListener 要需要的主题或监听器
     * @param {{(evt:TEvtArgs):any}} [listener] 要取消的监听器，只有当topicOrListner参数为topic时，才需要该参数
     * @returns {ISubject<TEvtArgs>} 可监听对象
     * @memberof IObservable
     */
    $unsubscribe(topicOrListener:string|{(evt:TEvtArgs):any},listener?:{(evt:TEvtArgs):any}):ISubject<TEvtArgs>;

    /**
     * 发送通知
     * 如果相关主题上有监听器，会逐个调用监听器
     * 如果不指明主题topic，默认topic=""
     *
     * @param {(string|TEvtArgs)} topicOrEvtArgs 通知的主题或事件参数
     * @param {TEvtArgs} [evt] 事件参数，只有topicOrEvtArgs是topic才需要该参数
     * @returns {ISubject<TEvtArgs>} 可监听对象
     * @memberof IObservable
     */
    $notify(topicOrEvtArgs:string|TEvtArgs,evt?:TEvtArgs):ISubject<TEvtArgs>;
}



/**
 * 可监听对象类
 * 实现订阅/发布模式
 * 它支持订阅/发布某个主题;如果未指定主题，默认主题为""
 * 它的所有关于订阅发布的成员字段/函数都是enumerable=false的
 * 一般用作其他类型的基类
 * 
 * @export
 * @class Observable
 * @implements {IObservable<TEvtArgs>}
 * @template TEvtArgs 事件参数的类型
 */
@intimate()
export class Subject<TEvtArgs> implements ISubject<TEvtArgs>{
    /**
     * 内部的主题列表，可以访问它，但不推荐直接使用，主要是debug时使用
     * 如果不指明主题topic，默认topic=""
     * 
     * @type {[topic:string]:Function[]}
     * @memberof Observable
     */
    $_topics:{[topic:string]:{(evt:TEvtArgs):any}[]};
    
    constructor(){
        Object.defineProperty(this,"$_topics",{enumerable:false,writable:true,configurable:false});
    }
    /**
     * 注册监听函数
     * $notify的时候，注册了相关主题的监听函数会被调用
     * 如果不指明主题topic，默认topic=""
     *
     * @param {(string|{(evt:TEvtArgs):any})} topicOrListener 监听函数或则主题
     * @param {{(evt:TEvtArgs):any}} [listener] 监听函数。如果第一个参数是主题，该参数才起作用。
     * @returns {ISubject<TEvtArgs>} 可监听对象
     * @memberof Observable
     */
    $subscribe(topicOrListener:string|{(evt:TEvtArgs):any},listener?:{(evt:TEvtArgs):any}):ISubject<TEvtArgs>{
        if(listener===undefined) {
            listener = topicOrListener as {(evt:TEvtArgs):any};
            topicOrListener="";
        }
        let topics = this.$_topics ||(this.$_topics={});
        let handlers = topics[topicOrListener as string] ||(topics[topicOrListener as string] =[]);
        handlers.push(listener);
        return this;
    }
    /**
     * 取消主题订阅
     * $notify操作时，被取消的监听器不会被调用
     * 如果不指明主题topic，默认topic=""
     *
     * @param {(string|{(evt:TEvtArgs):any})} topicOrListener 要需要的主题或监听器
     * @param {{(evt:TEvtArgs):any}} [listener] 要取消的监听器，只有当topicOrListner参数为topic时，才需要该参数
     * @returns {ISubject<TEvtArgs>} 可监听对象
     * @memberof Observable
     */
    $unsubscribe(topicOrListener:string|{(evt:TEvtArgs):any},listener?:{(evt:TEvtArgs):any}):ISubject<TEvtArgs>{
        if(listener===undefined) {
            listener = topicOrListener as {(evt:TEvtArgs):any};
            topicOrListener="";
        }
        let topics,handlers;
        if(!(topics = this.$_topics)) return this;
        if(!(handlers=topics[topicOrListener as string])) return this;
        for(let i =0,j=handlers.length;i<j;i++){
            let existed = handlers.shift();
            if(existed!==listener) handlers.push(existed);
        }
        return this;
    }
    /**
     * 发送通知
     * 如果相关主题上有监听器，会逐个调用监听器
     * 如果不指明主题topic，默认topic=""
     *
     * @param {(string|TEvtArgs)} topicOrEvtArgs 通知的主题或事件参数
     * @param {TEvtArgs} [evt] 事件参数，只有topicOrEvtArgs是topic才需要该参数
     * @returns {ISubject<TEvtArgs>} 可监听对象
     * @memberof Observable
     */
    $notify(topicOrEvtArgs:string|TEvtArgs,evtArgs?:TEvtArgs):ISubject<TEvtArgs>{
        if(evtArgs===undefined){
            evtArgs = topicOrEvtArgs as TEvtArgs;
            topicOrEvtArgs="";
        }
        let topics,handlers;
        if(!(topics = this.$_topics)) return this;
        if(!(handlers=topics[topicOrEvtArgs as string])) return this;
        for(const i in handlers){
            handlers[i].call(this,evtArgs);
        }
        return this;
    }
}

//defineMembers(Observable.prototype);

//================================================================

export enum DataTypes{
    Value,
    Object,
    Array
}


export interface IObservable<TData> extends ISubject<IChangeEventArgs<TData>>{
    $type:DataTypes;
    $extras?:any;
    $target?:TData;
    $get():TData|IObservable<TData>;
    $set(newValue:TData):IObservable<TData>;
    $update():boolean;
}

export enum ObservableModes{
    Default,
    Raw,
    Proxy
}

export function usingMode(mode:ObservableModes,statement:()=>any) {
    let accessMode = Observable.mode;
    try{
        Observable.mode=mode;
        statement();
    }finally{
        Observable.mode = accessMode;
    }
}



export interface IChangeEventArgs<TData>{
    type:ChangeTypes,
    index?:string|number;
    target?:any;
    value?:any,
    old?:any,
    item?:IObservable<TData>,
    sender?:any,
    cancel?:boolean
}

export enum ChangeTypes{
    Value,
    Replace,
    Append,
    Push,
    Pop,
    Shift,
    Unshift,
    Remove
}



let Undefined:any = {};


@intimate()
export class Observable<TData> extends Subject<IChangeEventArgs<TData>> implements IObservable<TData>{
    $type:DataTypes;

    $target:TData;

    $extras?:any;

    $schema?:ObservableSchema<TData>;

    $_index?:number|string;

    $_modifiedValue:TData;
    
    $_owner?:ObservableObject<any>;

    $_raw:(value?:TData)=>any;

    constructor(initValue:TData|ObservableSchema<TData>|{(val?:TData):any},index:{(val?:TData):any}|string|number,$_owner?:any,$extras?:any){
        super();
        let $schema:ObservableSchema<TData>=this.$schema;
        let $target:TData;
        let $_index:string|number;
        let $_raw:(val?:TData)=>any;
    
        if($_owner instanceof ObservableObject){
            $_index = index as string|number;
            $_raw = prop_raw($_index);
        }else {
            $_raw = index as {(val?:TData):any};
            $extras = $_owner;
            $_owner = undefined;
        }
        if(initValue instanceof ObservableSchema){
            if(this.$schema && this.$schema!==initValue) throw new Error("已经定义了schema");
            $schema = initValue;
            $target = clone($schema.$initData);
            if($_raw) $_raw.call(this,$target);
        }else {
            if(initValue!==undefined){
                $target = initValue===Undefined?undefined:initValue as TData;
                if($_raw) $_raw.call(this,$target);
            }else if($_raw) $target = $_raw.call(this);
        }
        
        intimate(this, {
            $target,$extras,$type:DataTypes.Value,$schema
            ,$_raw,$_index,$_modifiedValue:undefined,$_owner
        });

        if($schema) $schema.$initObservable(this);
    }
    

    $get():TData|IObservable<TData>{
        if( Observable.mode===ObservableModes.Proxy) return this;
        if(Observable.mode===ObservableModes.Raw) return this.$_raw();
        return (this.$_modifiedValue===undefined)?this.$target:(this.$_modifiedValue===Undefined?undefined:this.$_modifiedValue);
    }

    $set(newValue:TData):IObservable<TData>{
        if(Observable.mode===ObservableModes.Raw) {this.$_raw.call(this,newValue);return this;}
        this.$_modifiedValue=newValue===undefined?Undefined:newValue;
        return this;
    }
    $update():boolean{
        let newValue :any= this.$_modifiedValue;
        if(newValue===undefined) return true;
        this.$_modifiedValue=undefined;
        newValue =newValue===Undefined?undefined:newValue;
        let oldValue = this.$target;
        if(newValue!==oldValue) {
            this.$_raw(this.$target = newValue);
            let evtArgs:IChangeEventArgs<TData> = {type:ChangeTypes.Value,value:newValue,old:oldValue,sender:this};
            this.$notify(evtArgs);
            return evtArgs.cancel!==true;
        }
        return true;
        
    }

    toString(){let rawValue= this.$_raw();return rawValue?rawValue.toString():rawValue;}
    static mode:ObservableModes = ObservableModes.Default; 
}
//let ValueProxyProps = ["$modifiedValue","$type","$raw","$extras","$owner"];
//defineMembers(ObservableProxy.prototype,ObservableProxy.prototype);

export interface IObservableObject<TData extends {[index:string]:any}> extends IObservable<TData>{
    //$prop(name:string,prop:IObservable<TData>|boolean|{(proxy:ObservableObject<TData>,name:string):any}|PropertyDecorator):IObservableObject<TData>;
    [index:string]:any;   
}




function prop_raw<TProp,TObj>(name:string|number):{(val?:any):any}{
    
    return function(val?:TProp){
        let objProxy:ObservableObject<TObj> = (this as ObservableObject<TObj>).$_owner;

        return val===undefined
            ?(objProxy.$_modifiedValue===undefined
                ?objProxy.$target
                :(objProxy.$_modifiedValue===Undefined?null:objProxy.$_modifiedValue)
            )[name]
            :(objProxy.$_modifiedValue===undefined
                ?objProxy.$target
                :(objProxy.$_modifiedValue===Undefined?null:objProxy.$_modifiedValue)
            )[name]=val;   
    }      
}

function defineMember<TProp,TObject>(target:any,name:string,prop:Observable<TProp>|boolean|{(proxy:ObservableObject<TObject>,name:string):any}|PropertyDecorator):ObservableObject<TObject>{
    if(prop ===false){
        Object.defineProperty(target,name,{
            enumerable:true,configurable:false,
            get:()=>(this.$_modifiedValue===undefined?this.$target:(this.$_modifiedValue===Undefined?null:this.$_modifiedValue))[name],
            set:(newValue:any)=>(this.$_modifiedValue===undefined?this.$target:(this.$_modifiedValue===Undefined?null:this.$_modifiedValue))[name]=newValue
        });
        return this;
    }
    if(prop===true || prop instanceof Observable){
        prop = prop instanceof Observable?prop :(new Observable<TProp>(prop_raw(name)));
        prop.$_owner = target as ObservableObject<any>;
        prop.$_index = name;
        Object.defineProperty(target,name,{
            enumerable:true,
            configurable:false,
            get:()=>(prop as Observable<TProp>).$get(),
            set:(val:any)=>(prop as IObservable<TProp>).$set(val)
        });                
        
        return this;
    }
    
    if( typeof prop==='function'){
        let prop_value:any;
        Object.defineProperty(target,name,{
            enumerable:false,
            configurable:false,
            get:()=>{
                if(prop_value===undefined) prop_value=(prop as Function).call(this,this,name);
                return prop_value.get?prop_value.get():prop_value.$get();
            },
            set:(val)=>{
                if(prop_value===undefined) prop_value=(prop as Function).call(this,this,name);
                return prop_value.set?prop_value.set(val):prop_value.$set(val);
            }
        });  
        return this;
    }
    Object.defineProperty(target,name,prop);
    return this;
}
@intimate()
export class ObservableObject<TData> extends Observable<TData> implements IObservableObject<TData>{
    [index:string]:any;
    constructor(initValue:TData|ObservableSchema<TData>|{(val?:TData):any},index:{(val?:TData):any}|string|number,owner?:any,extras?:any){
        super(initValue,index,owner,extras);
        if(!this.$schema){
            this.$schema = new ObservableSchema<TData>(this.$target);
            this.$schema.$initObservable(this);
        }
        
        this.$type = DataTypes.Object;
    }

    $get():any{
        if(Observable.mode===ObservableModes.Raw) return this.$_raw();
        return this;
    }

    $set(newValue:TData):IObservableObject<TData>{
        super.$set(newValue||null);
        if(!newValue || Observable.mode===ObservableModes.Raw) return this;
        usingMode(ObservableModes.Proxy,()=>{
            for(const n in this){
                let proxy :any= this[n];
                if(proxy instanceof Observable) proxy.$set((newValue as any)[n] as any);
            }
        });
        return this;
    }

    $update():boolean{
        let result = super.$update();
        if(result===false) return false;
        usingMode(ObservableModes.Proxy,()=>{
            for(const n in this){
                let proxy :any= this[n];
                if(proxy instanceof Observable) proxy.$update();
            }
        });
        return true;
    }
}


export interface IObservableArray extends IObservable{
    length:number;
    [index:number]:any;
    item(index:number,item_value?:any):any;
    pop():any;
    push(item_value:any):IObservableArray;
    shift():any;
    unshift(item_value:any):IObservableArray;
    $item_convertor?:IObservable;
}



function item_raw(ownerProxy:IObservableArray){
    return function(val?:any){return val===undefined?ownerProxy.$target[this.$index]:ownerProxy.$target[this.$index]=val;}
}

function define_item(arrProxy:ObservableArray,index:number,item:Observable){
    if(item!==Undefined){
        item.$_index = index;
        item.$_owner = arrProxy;
        Object.defineProperty(arrProxy,index.toString(),{
            enumerable:true,
            configurable:true,
            get:item.$type===DataTypes.Value?()=>item.$get():()=>item,
            set:(val)=>item.$set(val)
        }); 
        
    }
}

export class ObservableArray extends Observable{
    $itemConvertor:(index:number,item_value:any,proxy:ObservableArray)=>Observable;
    $changes:IChangeEventArgs[];
    [index:number]:any;
    $length:number;
    length:number;
    constructor(raw:(val?:any)=>any,item_convertor?:(index:number,item_value:any,proxy:ObservableArray)=>IObservable,initValue?:any[],extras?:any){
        let target:any;
        super(raw,initValue,extras);
        target = this.$target;
        if(Object.prototype.toString.call(target)!=="[object Array]") raw.call(this,target=this.$target=[]);
        
        item_convertor ||(item_convertor=(index,item_value,proxy)=>{
            let item = new Observable(null);
            item.$_index = index;
            item.$_raw = item_raw(this);
            item.$target = item_value;
            return item;
        });
        for(let i =0,j=target.length;i<j;i++)((index,item_value)=>{
            if(item_value && item_value[ObservableArray.structToken]!==undefined) return;
            target.push(item_value);
            let item =  item_convertor.call(this,i as any as number,item_value,this);
            define_item(this,i,item)
        })(i,target.shift());

        defineMembers(this,{
            "$type":DataTypes.Array,
            "$target":target,
            "$length":target.length,
            "$itemConvertor":item_convertor,
            "$changes":undefined
        });
    }

    clear():IObservableArray{
        let old = this.$get();
        let changes = this.$changes|| (this.$changes=[]);
        let len = old.length;
        if(changes)for(const i in changes){
            let change = changes[i];
            if(change.type ===ChangeTypes.Push || change.type===ChangeTypes.Unshift){
                len++;
            }
        }
        let swicherValue = Observable.mode;
        try{
            Observable.mode=ObservableModes.Proxy;
            for(let i = 0;i<len;i++){
                let removeItem = this[i];
                if(removeItem){
                    delete this[i];
                    changes.push({
                        type:ChangeTypes.Remove,
                        index:i,
                        target:old,
                        item:removeItem,
                        sender:removeItem
                    });
                }
            }
        }finally{
            Observable.mode = swicherValue;
        }
        

        return this;
    }

    resize(newLength:number):IObservableArray{
        let arr = this.$get();
        let len = arr.length;
        if(len===newLength) return this;
        let changes = this.$changes ||(this.$changes=[]);
        if(len>newLength){
            for(let i =newLength;i<len;i++){
                let removeItem = this[i];
                delete this[i];
                changes.push({
                    type:ChangeTypes.Remove,
                    index:i,
                    item:removeItem,
                    target:arr,
                    value:arr[i]
                });
            }
            this.$length = newLength;
        }else if(len<newLength){
            for(let i =len;i<newLength;i++)((idx)=>{
                let appendItem = this.$itemConvertor(idx,undefined,this);
                define_item(this,i,appendItem);
                changes.push({
                    type:ChangeTypes.Append,
                    index:i,
                    item:appendItem,
                    target:arr
                });
            })(i);
            this.$length = newLength;
        }
        return this;
    }

    $set(newValue:any):IObservable{
        newValue || (newValue=[]);
        this.clear();
        super.$set(newValue);
        if(Observable.mode=== ObservableModes.Raw){
            this.$_raw(newValue);return this;
        }
        
        for(const i in newValue)((idx:number)=>{
            let item =  this.$itemConvertor(idx,newValue[idx],this);
            define_item(this,idx,item);
        })(i as any as number);
        this.$length = newValue.length;
        
        return this;
    }

    
    item(index:number,item_value?:any):any{
        if(item_value===undefined){
            let item = (this as any)[index];
            return Observable.mode?item:item.$get();
        }
        let len = this.length;
        let size = index>=len?index+1:len;
        let item = this.$itemConvertor(index,item_value,this);
        let oldItem :any;
        if(size>len){
            for(let i = len;i<size;i++)((idx:number)=>{
                let insertedItem = this.$itemConvertor(idx,undefined,this);
                insertedItem.$_owner = this;
                define_item(this,idx,insertedItem);
                (this.$changes || (this.$changes=[])).push({
                    sender:this,
                    type:ChangeTypes.Append,
                    index:idx,
                    value:insertedItem,
                    old:undefined
                });
            })(i);
            this.$length = size;
        }else {
            oldItem = this[index];
            
        }
        define_item(this,index,item);
        (this.$changes || (this.$changes=[])).push({
            sender:this,
            type:ChangeTypes.Replace,
            index:index,
            item:item,
            target:this.$get(),
            old:oldItem,
            value:item_value
        });

        return this;
    }

    push(item_value:any):ObservableArray{
        let index = this.length;
        let item = this.$itemConvertor(index,item_value,this);
        define_item(this,index,item);
        this.$length++;
        (this.$changes || (this.$changes=[])).push({
            sender:this,
            type:ChangeTypes.Push,
            index:index,
            item:item,
            value:item_value,
            target:this.$get()
        });
        return this;
    }

    pop():any{
        let len = this.length;
        if(!len)return this;
        let index = len-1;
        let removeItem = this[index];
        delete (this as any)[index];
        this.$length--;
        (this.$changes || (this.$changes=[])).push({
            sender:this,
            type:ChangeTypes.Pop,
            item:removeItem,
            index:index,
            target:this.$get(),
            value:removeItem.$get()
        });
        
        return removeItem.$get();
    }

    unshift(item_value:any):ObservableArray{
        let item = this.$itemConvertor(0,item_value,this);
        item.$_owner = this;
        //let changes = ;
        let len = this.length;
        for(let i =0;i<len;i++)((index)=>{
            let movedItem = this[index];
            let newIndex = index+1;
            define_item(this,newIndex,movedItem);
        })(i);
        define_item(this,0,item);
        
        this.$length++;
        (this.$changes || (this.$changes=[])).push({
            sender:this,
            type:ChangeTypes.Unshift,
            index:0,
            item:item,
            value:item_value,
            target:this.$get()
        });
        return this;
    }
    shift():any{
        let len = this.length;
        if(len===undefined)return;
        let removeItem = this[0];
        for(let i =1;i<len;i++)((idx)=>{
            let movedItem = this[idx];
            define_item(this,idx-1,movedItem);
        })(i);
        delete (this as any)[len-1];
        this.$length--;
        (this.$changes || (this.$changes=[])).push({
            sender:this,
            type:ChangeTypes.Shift,
            item:removeItem,
            index:0,
            //value:removeItem.$get(),
            target:this.$get()
        });
        return removeItem.$get();
    }
    $update():boolean{
        if(!super.$update()) return true;
        let changes = this.$changes;
        if(!changes || this.$changes.length===0) return true;
        this.$changes = undefined;

        let arr = this.$target;
        for(const i in changes){
            let change = changes[i];
            switch(change.type){
                case ChangeTypes.Push:
                    arr.push(change.value);
                    this.$notify(change);
                    //if(change.cancel!==true && change.item) change.item.$notify(change);
                    break;
                case ChangeTypes.Pop:
                    arr.pop();
                    this.$notify(change);
                    if(change.cancel!==true && change.item) {
                        change.sender = change.item;
                        change.item.$notify(change);
                    }
                    break;
                case ChangeTypes.Unshift:
                    arr.unshift(change.value);
                    this.$notify(change);
                    break;
                case ChangeTypes.Shift:
                    arr.shift();
                    this.$notify(change);
                    if(change.cancel!==true && change.item) {
                        change.sender = change.item;
                        change.item.$notify(change);
                    }
                    break;
                case ChangeTypes.Replace:
                    arr[change.index] = change.value;
                    this.$notify(change);
                    if(change.cancel!==true && change.old){
                        change.sender =change.item = change.old;
                        change.value = change.old.$get();
                        change.old = undefined;
                        change.sender.$notify(change);
                    } 
                    break;
            }
        }
        return true;
    }
    static structToken:string = "__STRUCT";
}
defineMembers(ObservableArray.prototype,ObservableArray.prototype);
Object.defineProperty(ObservableArray.prototype,"length",{
    enumerable:false,
    configurable:false,
    get:function():number{
        if(this.$length===undefined) {
            this.$length = this.$target.length;
        }
        return this.$length;
    }
    ,set:function(newLen:number){
        this.resize(newLen);
    }
});
 
export function  clone(src:any,deep?:boolean) {
    if(!src) return src;
    let srcT = Object.prototype.toString.call(src);
    if(srcT==="boolean" || srcT==="number" || srcT==="string") return src;
    let rs;
    if(srcT==="function"){
        let raw = src;
        if(src.$clone_raw) raw = src.$clone_raw;
        let rs = function () {return raw.apply(arguments);};
        Object.defineProperty(rs,"$clone_raw",{enumerable:false,writable:false,configurable:false,value:raw});
    }else if(srcT==="[object Object]") rs = {};
    else if(srcT==="[object Array]") rs = [];

    if(deep) for(const n in src)rs[n] = clone(src[n],true);
    else for(const n in src)rs[n] = src[n];

    return rs;
}
 
//=======================================================================
@intimate()
export class ObservableSchema<TData>{
    [index:string]:any;
    $type:DataTypes;
    $index:string|number;
    $path:string;
    $ctor:{new (initValue:TData|{(val?:TData):any},owner?:ObservableObject<any>|any,extras?:any):Observable<any>};
    $item_ctor:{new (raw?:Function,initData?:any,extras?:any,owner?:Observable<any>):Observable<any>};
    //$prop_models:{[index:string]:Model};
    $owner?:ObservableSchema<TData>;
    $item_schema?:ObservableSchema<TData>;
    $initData?:any;
    constructor(initData:TData,index?:string|number,owner?:ObservableSchema<any>){
        let path;
        index = index===undefined|| index===null?"":index;
        if(owner){
            let ppath = owner.$path;
            path = ppath?ppath + "." + index:index;
        }else path = index;

        intimate(this,{
            "$type":DataTypes.Value
            ,"$index":index
            ,"$path":path
            ,"$owner":owner
            ,"$ctor":Observable
            ,"$item_schema":null
            ,"$initData":initData
        });
        if(initData){
            let t = Object.prototype.toString.call(initData);
            if(t==="[object Object]") {
                this.$asObject();           
                for(const n in initData){
                    this.$defineProp(n,initData[n]);
                }
            }
            else if(t==="[object Array]"){
                throw new Error("not implement.");
            }
        }
    }
    

    

    $asObject():ObservableSchema<TData>{
        if(this.$type===DataTypes.Object) return this;
        if(this.$type === DataTypes.Array) throw new Error("无法将ObservableSchema从Array转化成Object.");
        this.$type = DataTypes.Object;
        let objSchema = this;
        class NewType extends ObservableObject<TData>{
            constructor(initValue:TData|{(val?:TData):any},owner?:ObservableObject<any>|any,extras?:any){
                if(owner instanceof ObservableObject){
                    super(initValue as TData
                        ,objSchema.$_index as string|number
                        ,owner as ObservableObject<any>
                        ,extras as any);
                }else {
                    super(undefined,initValue as {(val?:TData):any},extras);
                }
                
            }
        };
        NewType.prototype.$schema= this;
        this.$ctor= NewType;
        return this;
    }

    $defineProp<TProp>(propname:string,initValue?:TProp):ObservableSchema<TProp>{
        if(this.$type!==DataTypes.Object) throw new Error("调用$defineProp之前，要首先调用$asObject");
        let propSchema :ObservableSchema<TProp> = new ObservableSchema<TProp>(initValue,propname,this);
        if(propSchema.$type=== DataTypes.Object){
            defineMember<TProp,any>(this.$ctor.prototype,name,(owner,name)=>new this.$ctor(prop_raw(name),initValue,propSchema,owner));
        }else defineMember<TProp,TData>(this.$ctor.prototype,name,true);
        Object.defineProperty(this,propname,propSchema);        
        return propSchema;
    }

    $initObservable(ob:Observable<TData>){
        for(const n in this){
            let propSchema = this[n] as any as ObservableSchema<any>;
            defineMember<any,TData>(ob,n,(owner,name)=>new this.$ctor(prop_raw(name),propSchema,owner));
        }
    }
    
    $create(initValue:TData|{(val?:TData):any},owner?:ObservableObject<any>|any,extras?:any){
        return new this.$ctor(initValue,owner,extras);
    }
}


//=======================================================================




export enum ComponentReadyStates{
    Defined,
    Completed
}

export interface IComponentMeta {
    $reactives?:{[attr:string]:ReactiveTypes};
    $templates?:{[attr:string]:string|Function};
    $actions?:{[attr:string]:string};
    $wrapType?:Function;
    $rawType?:Function;
    $tag?:string;
    $render?:(component:IComponent,partial:string,container:any)=>any;
    $readyState?:ComponentReadyStates;
}

export type TComponentType = {new ():any} & IComponentMeta;



export interface IComponent{
    [attr:string]:any;
}




export enum ReactiveTypes{
    Local,
    In,
    Out,
    Ref,
    Each
}

export const componentTypes: {[tag:string]:{new():{}}}={};

let currentComponentType:TComponentType;

export function reactive(type?:ReactiveTypes|string):any{
    return function(target:any,propName:string){
        type = typeof type ==="string"?ReactiveTypes[type]:type;
        (target.$reactives || (target.$reactives=[]))[propName] = type || ReactiveTypes.Local;
    }
}
export function action(async?:boolean){
    return function(target: any, propertyName: string){
        (target.$actions || (target.$actions=[]))[propertyName] = async;
    };
}

export function template(partial?:string){
    return function(target: any, propertyName: string){
        (target.$templates || (target.$templates=[]))[partial||""] = propertyName;
    };
}

export function component(tag:string|TComponentType){
    function decorator<T extends {new(...args: any[]):{}}>(RawType:T){
        Object.defineProperty(RawType,"$tag",{
            enumerable:false,writable:false,configurable:false,value:tag
        });
        let WrappedType= class extends RawType{
            constructor(...args:any[]){
                let accessMode = Observable.mode;
                try{
                    Observable.mode = ObservableModes.Raw;
                    if(!args.length) super();
                    else RawType.apply(this,args);
                }finally{
                    Observable.mode = accessMode;
                }
                
                intializeActions(this,WrappedType,RawType);
            }
        };
        let info:IComponentMeta = {
            "$reactives":RawType.prototype.$reactives || (RawType as any).$reactives
            ,"$templates":RawType.prototype.$templates || (RawType as any).$templates
            ,"$actions":RawType.prototype.$actions || (RawType as any).$actions
            ,"$wrapType":WrappedType
            ,"$rawType":RawType
            //,"$readyState":ComponentReadyStates.Defined
            ,"$tag":tag as string
        };
        for(let n in info){
            delete RawType.prototype[n];
        }
        defineMembers(RawType,info,false);
        defineMembers(WrappedType,info,false);
        Object.defineProperty(WrappedType,"$readyState",{enumerable:false,configurable:true,writable:false,value:ComponentReadyStates.Defined});
        Object.defineProperty(RawType,"$readyState",{enumerable:false,configurable:true,writable:false,value:ComponentReadyStates.Defined});
        
        currentComponentType = WrappedType;
        //let wrappedProto = ;
        try{
            WrappedType.prototype = new RawType();
        }finally{
            currentComponentType=undefined;
        }
        initializeReactives(WrappedType);
        initializeTemplates(WrappedType);
        componentTypes[tag as string] = WrappedType;
        Object.defineProperty(WrappedType,"$readyState",{enumerable:false,configurable:false,writable:false,value:true});
    
        
        return WrappedType;
    }
    
    if(typeof tag==="function"){
        let rawType = tag as Function;
        return decorator(rawType as any);
    }else return decorator;
}
function initializeTemplates(WrappedType:TComponentType){
    let templates = WrappedType.$templates;
    
    Object.defineProperty(WrappedType,"$render",{enumerable:false,configurable:false,writable:false,value:function(component:IComponent,partial?:string,container?:any):any{
        partial||(partial="");
        let nameOrMethod = templates[partial];
        if(nameOrMethod!==undefined){
            if((nameOrMethod as any).$virtual_node!==undefined) return (nameOrMethod as Function).call(component,container);
            let renderMethod = component[nameOrMethod as string] as any;
            if(!renderMethod) return;
            
            let templateMethod:Function;
            let node :any;
            let accessMode = Observable.mode;
            try{
                
                Observable.mode = ObservableModes.Proxy;
                node = renderMethod.call(component,container);
                if(ELEMENT.isElement(node)){
                    templateMethod = renderMethod;
                    Object.defineProperty(templateMethod,"$virtual_node",{enumerable:false,writable:false,configurable:false,value:false});
                }else{
                    templateMethod = (component:IComponent,_container:any)=>(node as VirtualNode).render(component,container);
                    Object.defineProperty(templateMethod,"$virtual_node",{enumerable:false,writable:false,configurable:false,value:node});
                }
            }finally{
                Observable.mode = accessMode;
            }
            component[nameOrMethod as string] = templateMethod;
            return templateMethod === renderMethod?node:templateMethod.call(component,component,container);

        }
        return undefined;
    }});
}

function intializeActions(component:any,WrappedType:TComponentType,RawType:TComponentType){
    Object.defineProperty(component,"$private_updateTick",{
        enumerable:false,configurable:false,writable:true,value:undefined
    });

    let actions = WrappedType.$actions;
    for(const n in actions)((name:string,method:Function,component:any,WrappedType:TComponentType)=>{
        let action :any= function(){
            let rs= method.apply(component,arguments);
            if(component.$private_updateTick) clearTimeout(component.$private_updateTick);
            component.$private_updateTick = setTimeout(()=>{
                clearTimeout(component.$private_updateTick);
                component.$private_updateTick = undefined;
                let reactives = WrappedType.$reactives;
                let accessMode = Observable.mode;
                try{
                    Observable.mode = ObservableModes.Proxy;
                    for(const n in reactives) component[n].$update();
                }finally{
                    Observable.mode = accessMode;
                }
            },0);
            return rs;
        };
        Object.defineProperty(component,name,{
            enumerable:false,configurable:false,writable:false,value:action
        });
        Object.defineProperty(action,"$actionName",{
            enumerable:false,configurable:false,writable:false,value:name
        });
    })(n,RawType.prototype[n],component,WrappedType);
}

function initializeReactives(WrappedType:TComponentType){
    let reactives = WrappedType.$reactives;
    if(reactives)for(const n in reactives)((name:string,reactiveType:ReactiveTypes,component:any)=>{
        let privateName = `$private_${name}`;
        let initData = component[name];
        let model = new ObservableSchema(name,initData);
        if(reactiveType=== ReactiveTypes.Each){
            defineReactive(name,privateName,WrappedType,enumerableReactiveCreator(name,()=>model.$createProxy(initData)),true);
        }else {
            defineReactive(name,privateName,WrappedType,()=>model.$createProxy(initData),false);
        }
        
    })(n,reactives[n],WrappedType.prototype);        
}

function enumerableReactiveCreator(name:string,proxyCreator:()=>IObservable):any{
    return function createEnumerableProxy(proxy?:IObservable){
        let component:IComponent= this;
        proxy ||(proxy=proxyCreator()) ;
        Object.defineProperty(proxy,"$new",{
            enumerable:false,configurable:false,writable:false,value:function(){
                let newProxy = proxyCreator();
                createEnumerableProxy.call(component,newProxy);
                Object.defineProperty(component,name,{
                    enumerable:true,configurable:true,get:()=>newProxy.$get(),set:(val)=>newProxy.$set(val)
                });
                return newProxy;
            }
        });
        Object.defineProperty(proxy,"$replace",{
            enumerable:false,configurable:false,writable:false,value:function(newProxy:IObservable){
                createEnumerableProxy.call(component,newProxy);
                Object.defineProperty(component,name,{
                    enumerable:true,configurable:true,get:()=>newProxy.$get(),set:(val)=>newProxy.$set(val)
                });
                return newProxy;
            }
        });
        return proxy;
    }
}



function defineReactive(name:string,privateName:string,WrappedType:TComponentType,proxyCreator:()=>IObservable,configurable:boolean){
    let descriptor = {
        enumerable:true,
        configurable:true,
        get:function(){
            let proxy = this[privateName];
            if(!proxy) Object.defineProperty(this,privateName,{enumerable:false,writable:false,configurable:true,value:proxy=proxyCreator.call(this)});
            else{
                delete this[privateName];
                Object.defineProperty(this,name,{
                    enumerable:true,configurable:configurable,get:()=>proxy.$get(),set:(val)=>proxy.$set(val)
                });
            } 
            return proxy.$get(); 
        },
        set:function(val){
            let proxy = this[privateName];
            if(!proxy) Object.defineProperty(this,privateName,{enumerable:false,writable:false,configurable:true,value:proxy=proxyCreator.call(this)});
            else{
                delete this[privateName];
                Object.defineProperty(this,name,{
                    enumerable:true,configurable:configurable,get:()=>proxy.$get(),set:(val)=>proxy.$set(val)
                });
            } 
            proxy.$set(val); 
        }
    };
    Object.defineProperty(WrappedType.prototype,name,descriptor);
}


let evtnameRegx = /(?:on)?([a-zA-Z_][a-zA-Z0-9_]*)/;
export class VirtualNode{
    tag?:string;
    attrs?:{[name:string]:any};
    content?:any;
    children?:VirtualNode[];
    constructor(){}

    genCodes(variables:any[],codes?:string[],tabs?:string):string[]{
        return null;
    }

    genChildrenCodes(variables:any[],codes?:string[],tabs?:string):string[]{
        return null;
    }

    render(component:IComponent,container?:any):any{
        let variables :any[]=[];
        let codeText = this.genCodes(variables).join("");
        console.log(codeText);
        let actualRenderFn = new Function("variables","ELEMENT","component","container",codeText) as {(variables,ELEMENT:any,component:IComponent,container?:any):any};
        this.render =(component,container)=> actualRenderFn(variables,ELEMENT,component,container);
        return this.render(component,container);
    }

    renderChildren(component:IComponent,container?:any):any{
        let variables :any[]=[];
        let actualRenderFn = new Function("ELEMENT","component","elem",this.genChildrenCodes(variables).join("")+"return children;\n") as {(ELEMENT:any,component:IComponent,container?:any):any};
        this.renderChildren =(component,container)=> actualRenderFn(ELEMENT,component,container);
        return this.renderChildren(component,container);
    }
}

export class VirtualTextNode extends VirtualNode{
    
    constructor(public content:any){
        super();
    }
    genCodes(variables:any[],codes?:string[],tabs?:string):string[]{
        codes || (codes=[]);tabs || (tabs="");
        if(this.content instanceof Observable){
            if(this.content.$extras.path==="name") debugger;
            codes.push(`${tabs}var proxy=component.${this.content.$extras.path};\n`);
            codes.push(`${tabs}var elem=ELEMENT.createText(proxy.$get());\n`);
            codes.push(`${tabs}proxy.$subscribe(function(e){elem.nodeValue = ELEMENT.changeEventToText(e);})\n`);
        }else{
            codes.push(`${tabs}var elem = ELEMENT.createText('${this.content.replace(/'/,"\\'")}');\n`);
        }
        codes.push(`${tabs}if(container) ELEMENT.appendChild(container,elem);\n`);
        codes.push(`${tabs}return elem;\n`);
        return codes;
    }
}
export class VirtualElementNode extends VirtualNode{
    
    children?:VirtualNode[];

    constructor(public tag:string,public attrs:{[name:string]:any}){
        super();
    }
    genCodes(variables:any[],codes?:string[],tabs?:string):string[]{
        codes || (codes=[]);tabs || (tabs="");
        codes.push(`${tabs}var elem=ELEMENT.createElement("${this.tag}");\n`);
        
        let repeatPars :any[];
        for(const attrname in this.attrs){
            let attrValue= this.attrs[attrname];
            if(attrname==="repeat") {
                repeatPars = [];
                for(let i in attrValue) repeatPars.push(`component.${attrValue[i].$extras.path}`);
                continue;
            }
            
            if(attrValue&& attrValue.$actionName){
                let match = attrname.match(evtnameRegx);
                let evtName = match?match[1]:attrname;
                codes.push(`${tabs}ELEMENT.attach(elem,"${evtName}",component.${attrValue.$actionName});\n`);
            }else if(attrValue instanceof Observable){
                let binder = attrBinders[name];
                if(binder)
                    codes.push(`${tabs}ELEMENT.$attrBinders["${attrname}"].call(component,elem,compnent.${attrValue.$extras.path});\n`);
                else 
                    codes.push(`${tabs}ELEMENT.setAttribute(elem,"${attrname}","${attrValue}");\n`);
            }else {
                codes.push(`${tabs}ELEMENT.setAttribute(elem,"${attrname}","${attrValue}");\n`);
            }
        }
        codes.push(`${tabs}if(container) ELEMENT.appendChild(container,elem);\n`);

        if(repeatPars){
            codes.push(`${tabs}ELEMENT.$repeat(component,elem,vars[${variables.length}],${repeatPars.join(",")});\n`);
            variables.push(this);
        }else{
            this.genChildrenCodes(variables,codes,tabs);
        }
        
        codes.push(`${tabs}return elem;\n`);
        return codes;
    }
    genChildrenCodes(variables:any[],codes?:string[],tabs?:string):string[]{
        codes || (codes=[]);tabs || (tabs="");
        if(this.children && this.children.length){
            codes.push(tabs + "var child;var children=[];\n");
            let subTabs = tabs+"\t";
            for(let i in this.children){
                let child = this.children[i];
                codes.push(`${tabs}children.push(child=(function(ELEMENT,component,container){\n`);
                child.genCodes(variables,codes,subTabs);
                codes.push(`${tabs}})(ELEMENT,component,elem));\n`);
            }
        }
        return codes;
    }
}

export class VirtualComponentNode extends VirtualNode{
    children?:VirtualNode[];
    constructor(public tag:string,public attrs:{[name:string]:any},public content:any){
        super();
    }
    genCodes(variables:any[],codes?:string[],tabs?:string):string[]{
        codes || (codes=[]);tabs || (tabs="");
        let typeAt = variables.length;
        codes.push(`${tabs}var subComponent = variables[${typeAt}].$create();\n`);
        variables.push(this.content);
        let ComponentType = this.content as TComponentType;
        for(const attrName in this.attrs){
            let attrValue = this.attrs[attrName];
            let reactiveType = ComponentType.$reactives[attrName];
            if(reactiveType===ReactiveTypes.Local || reactiveType===ReactiveTypes.Each) throw new Error(`${this.tag}.${attrName}是内部变量，不可以在外部赋值`);
            
            if(reactiveType === ReactiveTypes.Out){
                if(attrValue instanceof Observable){
                    codes.push(`${tabs}subComponent.${attrName}.$subscribe(function(e){component.${attrValue.$extras.path}.$set(e.item?e.item.$get():e.value);});\n`);
                    
                }else {
                    codes.push(`${tabs}subComponent.${attrName}.$subscribe(function(e){component.${attrName}=e.item?e.item.$get():e.value;});\n`);
                }
            }else if(reactiveType===ReactiveTypes.In){
                if(attrValue instanceof Observable){
                    codes.push(`${tabs}subComponent.${attrName}.$set(component.${attrValue.$extras.path}.$get());\n`);
                }else{
                    codes.push(`${tabs}subComponent.${attrName}.$set(component.${attrName});\n`);
                }
                
            }else if(reactiveType===ReactiveTypes.Ref){
                if(attrValue instanceof Observable){
                    codes.push(`${tabs}subComponent.${attrName}.$subscribe(function(e){component.${attrValue.$extras.path}.$set(e.item?e.item.$get():e.value);});\n`);
                    codes.push(`${tabs}component.${attrValue.$extras.path}.$subscribe(function(e){subComponent.${attrName}.$set(e.item?e.item.$get():e.value);});\n`);
                }else {
                    codes.push(`${tabs}subComponent.${attrName}.$subscribe(function(e){component.${attrValue.$extras.path}.$set(e.item?e.item.$get():e.value);});\n`);
                    console.warn(`父组件的属性未设置未可观测对象，父组件的值发生变化后，无法传入${this.tag}.${attrName}`);
                }

            }else{
                codes.push(`${tabs}if(subComponent.${attrName}.$set) subComponent.${attrName}.$set(variables[${variables.length}]);else subComponent.${attrName}=variables[${variables.length}];\n`);
                variables.push(attrValue);
            }
        };
        codes.push(`${tabs}if(subComponent.initialize) setTimeout(function(){subComponent.initialize(elem);},0);\n`);
        codes.push(`${tabs}var elem = variables[${typeAt}].$render.call(subComponent,variables[${variables.length}]);\n`);
        variables.push(this);
        codes.push(`${tabs}if(container) ELEMENT.appendChild(container,elem);\n`);
        return codes;
    }
}

function buildRepeat(component:IComponent,container:any,vnode:VirtualNode,each:IObservable,value:IObservable,key:IObservable){
    ELEMENT.removeAllChildrens(container);
    
    for(let k in each){
        if(key)(key as any).$new(k);
        if(value) (value as any).$replace(each[k]);
        vnode.renderChildren(component,container);
    }
}



export let ELEMENT:any =function(tag:string,attrs:{[name:string]:any}){
    //modeling
    if(currentComponentType && (currentComponentType as IComponentMeta).$readyState!==ComponentReadyStates.Completed) {
        return;
    };
    let ComponentType = componentTypes[tag];
    let vnode:VirtualNode =ComponentType?new VirtualComponentNode(tag,attrs,ComponentType): new VirtualElementNode(tag,attrs);
    if(arguments.length>2){
        let children:VirtualNode[] = vnode.children=[];
        for(let i=2,j=arguments.length;i<j;i++){
            let child = arguments[i];
            if(!child) continue;
            if(child.tag)children.push(child);
            else children.push(new VirtualTextNode(child)); 
        }
    }
    return vnode; 
};
ELEMENT.$repeat =buildRepeat;
ELEMENT.isElement=(elem):any=>{
    return (elem as HTMLElement).nodeType === 1;
};

ELEMENT.createElement=(tag:string):any=>{
    return document.createElement(tag);
};

ELEMENT.createText=(txt:string):any=>{
    return document.createTextNode(txt);
};


ELEMENT.setAttribute=(elem:any,name:string,value:any)=>{
    elem.setAttribute(name,value);
};

ELEMENT.appendChild=(elem:any,child:any)=>{
    elem.appendChild(child);
};

ELEMENT.removeAllChildrens=(elem:any)=>{
    elem.innerHTML = elem.nodeValue="";
};

ELEMENT.attach = (elem:any,evtname:string,handler:Function)=>{
    if(elem.addEventListener) elem.addEventListener(evtname,handler,false);
    else if(elem.attachEvent) elem.attachEvent('on' + evtname,handler);
    else elem['on'+evtname] = handler;
}

let attrBinders:{[name:string]:{(elem:any,bindValue:IObservable,isBibind?:boolean):any}} ={};
function changeEventToText(e:IChangeEventArgs):string{
    let value = e.value===undefined?(e.item?e.item.$get():e.value):e.value;
    return (value===undefined || value===null)?"":value.toString();
}

attrBinders["value"] = (elem:any,bindValue:IObservable,isBibind?:boolean)=>{
    bindValue.$subscribe((e:IChangeEventArgs)=>{
        (elem as HTMLInputElement).value = changeEventToText(e);
    });
    elem.value = bindValue.toString();
};

attrBinders["repeat"] = (elem:any,bindValue:IObservable,isBibind?:boolean)=>{
    bindValue.$subscribe((e:IChangeEventArgs)=>{
        (elem as HTMLInputElement).value = changeEventToText(e);
    });
    elem.value = bindValue.toString();
};

let eventBinders:{[name:string]:{(elem:any,handler:Function):void}} ={};
eventBinders["onchange"] = (elem:any,handler:Function)=>{
    let bindEdit =(elem,handler)=>{
        let tick :number;
        let evtHandler = (e)=>{
            if(tick) clearTimeout(tick);
            tick = setTimeout(() => {
                clearTimeout(tick);tick =0;
                handler(e);
            }, 150);
        };  
        ELEMENT.attach(elem,"keydown",evtHandler);
        ELEMENT.attach(elem,"keyup",evtHandler);
        ELEMENT.attach(elem,"keypress",evtHandler);
    };
    if(elem.tagName==="INPUT"){
        if(elem.type==="text")
            bindEdit(elem,handler);
    } else if(elem.tagName==="TEXTAREA"){
        bindEdit(elem,handler);
    }


    ELEMENT.attach(elem,"onchange",handler);
    ELEMENT.attach(elem,"focusout",handler);
    ELEMENT.attach(elem,"blur",handler);
    
};

let YA={
    Subject, ObservableModes,Observable,ObservableObject,ObservableArray, Schema: ObservableSchema,
    component,reactive,action,
    ELEMENT: ELEMENT
};
if(typeof window!=='undefined') (window as any).YA = YA;
export default YA;





